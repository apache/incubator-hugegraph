/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

import "store_common.proto";

option java_multiple_files = true;
option java_package = "org.apache.hugegraph.store.grpc.query";
option java_outer_classname = "AggPushDownQueryProto";

service QueryService {
  rpc query(stream QueryRequest) returns (stream QueryResponse) {}
  // Simple query
  rpc query0(QueryRequest) returns (QueryResponse) {}
  rpc count(QueryRequest) returns (QueryResponse) {}
}

enum AggregationType {
  COUNT = 0;
  SUM = 1;
  MIN = 2;
  MAX = 3;
  AVG = 4;
}

message AggregateFunc {
  AggregationType funcType = 1;
  bytes field = 2;  // Property ID. For COUNT, set to -1.
  string type = 3;  // Initialize buffer type.
}

enum ScanType {
  TABLE_SCAN = 0;
  PRIMARY_SCAN = 1;
  INDEX_SCAN = 2;
  NO_SCAN = 3; // Only scan index.
}

message ScanTypeParam {
  bytes key_start = 1;
  bytes key_end = 2;
  int32 scan_boundary = 3;      // Range boundary.
  bool is_prefix = 4;           // Distinguish ID or prefix.
  bool is_secondary_index = 5;  // Distinguish primary scan from index scan.
  int32 code = 6;               // ID code.
  bytes id_prefix = 7;          // Element ID prefix when parsing index.
}

message Index {
  repeated ScanTypeParam params = 1;
}

enum DeDupOption {
  NONE = 0;
  DEDUP = 1;
  LIMIT_DEDUP = 2;
  PRECISE_DEDUP = 3;
}

message QueryRequest{
  string queryId = 1;
  string graph = 2;
  string table = 3;

  repeated AggregateFunc functions = 4;
  // Attribute trimming: if empty, return all attributes;
  // the 'aggregation' field is treated separately and excluded.
  // If there is a GROUP BY clause, selected attributes must be a subset of the GROUP BY columns.
  repeated bytes property = 5;
  repeated bytes group_by = 6;                  // Group-by columns.
  repeated uint32 having = 7;                   // HAVING filter (not implemented yet).
  repeated bytes order_by = 8;                  // Order-by columns.
  bool sort_order = 9;                          // Ascending (true) or descending.
  bool null_property = 10;                      // Do not use properties; only return key.

  ScanType scan_type = 11;                      // Table scan type. If an index exists, this field is ignored.

  repeated ScanTypeParam scan_type_param = 12;  // ID or prefix (only start is used).

  DeDupOption dedup_option = 13;                // Whether key deduplication is required.

  bytes condition = 21;                         // Condition.
  bytes position = 24;                          // Offset ~ offset + limit.
  uint32 limit = 23;                            // Page size.
  uint32 offset = 25;                           // Offset.

  double sample_factor = 31;                    // Sampling rate; should be less than 1.

  repeated bytes olap_property = 32;

  // indexes ((index,index) or (index, index))
  repeated Index indexes = 41;

  bool load_property_from_index = 42;
  bool check_ttl = 43;
  // group by based on element label id
  bool group_by_schema_label = 44;
}

message QueryResponse {
  string query_id = 1;
  bool is_ok = 2;
  bool is_finished = 3;
  string message = 4;
  repeated Kv data = 5;
}
