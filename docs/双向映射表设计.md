# 双向映射表设计 - vertexId ↔ vectorId

## 问题背景

### 为什么需要映射表？

1. **jVector的限制**：
   - jVector内部使用自己的ID系统（vectorId）
   - 向量搜索返回的是vectorId列表
   - 用户需要的是vertexId（业务ID）

2. **数据转换需求**：
   - 写入时：vertexId → vectorId（存储映射）
   - 查询时：vectorId → vertexId（查询转换）
   - 删除时：vertexId → vectorId（查找映射）

## 存储设计

### RocksDB Column Family

```
Column Family: vector_mapping

双向存储：
  Key: "vertex_id:" + vertexId
  Value: vectorId
  
  Key: "vector_id:" + vectorId
  Value: vertexId
```

### 为什么双向存储？

| 操作 | 需要的映射 | 查询方向 |
|------|----------|--------|
| **写入** | vertexId → vectorId | 单向 |
| **查询** | vectorId → vertexId | 反向 |
| **删除** | vertexId → vectorId | 单向 |
| **恢复** | 两个方向都需要 | 双向 |

## 实现细节

### VectorMappingManager

```java
public class VectorMappingManager {
    
    private final RocksDB rocksDB;
    private final ColumnFamilyHandle mappingCF;
    
    /**
     * 写入映射关系
     * 在向jVector添加向量后调用
     */
    public void putMapping(String vertexId, long vectorId) {
        // 正向映射：vertexId → vectorId
        rocksDB.put(mappingCF, 
            ("vertex_id:" + vertexId).getBytes(), 
            String.valueOf(vectorId).getBytes());
        
        // 反向映射：vectorId → vertexId
        rocksDB.put(mappingCF, 
            ("vector_id:" + vectorId).getBytes(), 
            vertexId.getBytes());
    }
    
    /**
     * 删除映射关系
     * 在从jVector删除向量后调用
     */
    public void deleteMapping(String vertexId, long vectorId) {
        rocksDB.delete(mappingCF, ("vertex_id:" + vertexId).getBytes());
        rocksDB.delete(mappingCF, ("vector_id:" + vectorId).getBytes());
    }
    
    /**
     * 根据vertexId查询vectorId
     * 用于删除操作
     */
    public long getVectorId(String vertexId) {
        byte[] value = rocksDB.get(mappingCF, 
            ("vertex_id:" + vertexId).getBytes());
        if (value == null) {
            throw new VectorException("Vector not found for vertex: " + vertexId);
        }
        return Long.parseLong(new String(value));
    }
    
    /**
     * 根据vectorId查询vertexId
     * 用于查询结果转换
     */
    public String getVertexId(long vectorId) {
        byte[] value = rocksDB.get(mappingCF, 
            ("vector_id:" + vectorId).getBytes());
        if (value == null) {
            throw new VectorException("Vertex not found for vector: " + vectorId);
        }
        return new String(value);
    }
    
    /**
     * 批量查询vertexId
     * 用于查询结果转换
     */
    public List<String> getVertexIds(List<Long> vectorIds) {
        return vectorIds.stream()
            .map(this::getVertexId)
            .collect(Collectors.toList());
    }
}
```

## 工作流程

### 写入流程

```
1. 用户写入Vertex（含向量属性）
   ↓
2. GraphTransaction.commit()
   ↓
3. VectorIndexCoordinator拦截
   ↓
4. VectorManager处理向量操作
   ↓
5. 向jVector添加向量 → 获得vectorId
   ↓
6. VectorMappingManager.putMapping(vertexId, vectorId)
   ↓
7. 记录offset到RocksDB
```

### 查询流程

```
1. 用户调用VectorSearchAPI搜索
   ↓
2. jVector搜索 → 返回TopK的vectorId列表
   ↓
3. VectorMappingManager.getVertexIds(vectorIds)
   ↓
4. 返回vertexId列表给用户
```

### 删除流程

```
1. 用户删除Vertex
   ↓
2. GraphTransaction.commit()
   ↓
3. VectorIndexCoordinator拦截
   ↓
4. VectorManager处理删除操作
   ↓
5. VectorMappingManager.getVectorId(vertexId) → 获得vectorId
   ↓
6. 从jVector删除向量
   ↓
7. VectorMappingManager.deleteMapping(vertexId, vectorId)
   ↓
8. 记录offset到RocksDB
```

## 恢复时的处理

### Crash恢复流程

```
启动时：
  1. 读取offset
  2. 扫描RocksDB中的Vertex数据
  3. 对于每个包含向量属性的Vertex：
     a. 提取向量数据
     b. 向jVector添加向量 → 获得新的vectorId
     c. 更新映射表（旧的vectorId可能不同）
     d. 记录新的offset
```

### 为什么vectorId可能不同？

- jVector是内存索引，Crash后重启会重新初始化
- 重新添加向量时，jVector可能分配不同的ID
- 因此需要更新映射表中的vectorId

## 性能考虑

### 写入性能

| 操作 | 时间 | 说明 |
|------|------|------|
| jVector添加向量 | ~1ms | 主要耗时 |
| RocksDB写入映射 | ~0.1ms | 快速 |
| 总计 | ~1.1ms | 可接受 |

### 查询性能

| 操作 | 时间 | 说明 |
|------|------|------|
| jVector搜索 | ~10ms | 主要耗时 |
| RocksDB查询映射 | ~0.1ms/条 | 快速 |
| 总计 | ~10ms + 0.1ms*K | K为TopK数量 |

### 存储开销

```
每个映射关系：
  正向映射：key(~20B) + value(8B) = ~28B
  反向映射：key(~20B) + value(~20B) = ~40B
  总计：~68B/条

假设100万个向量：
  100万 * 68B = ~68MB
  可接受
```

## 一致性保证

### 写入一致性

```
VectorManager处理向量操作时：
  1. 向jVector添加向量（内存）
  2. 将映射关系写入RocksDB（持久化）
  
如果步骤2失败：
  - jVector中有数据，但RocksDB中没有映射
  - 恢复时会重新添加，可能导致重复
  - 需要在恢复时检查并去重
```

### 查询一致性

```
查询时：
  1. jVector搜索返回vectorId
  2. 查询RocksDB获取vertexId
  
如果映射不存在：
  - 说明向量索引还未完全同步
  - 返回错误或等待
```

## 总结

双向映射表是整个向量索引方案中的关键组件：

✅ **必需**：连接jVector和HugeGraph的业务ID
✅ **简单**：RocksDB中的KV存储
✅ **高效**：查询性能快
✅ **可靠**：持久化存储
✅ **易恢复**：Crash后可重建

